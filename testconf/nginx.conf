# Generic startup file.
user www-data;

#usually equal to number of CPUs you have. run command "grep processor /proc/cpuinfo | wc -l" to find it
worker_processes  auto;
worker_cpu_affinity auto;

error_log  /var/log/nginx/error.log;
pid        /var/run/nginx.pid;

# Keeps the logs free of messages about not being able to bind().
#daemon     off;

events {
    worker_connections  1024;
}

http {
    #rewrite_log on;

    include	/etc/nginx/mime.types;
    default_type       application/octet-stream;
    access_log         /var/log/nginx/access.log;
    sendfile           on;
    #tcp_nopush         on;
    keepalive_timeout  3;
    #tcp_nodelay        on;
    #gzip               on;
    #php max upload limit cannot be larger than this
    client_max_body_size 13m;
    index              index.php index.html index.htm;

    # Upstream to abstract backend connection(s) for PHP.
    upstream php {
        #this should match value of "listen" directive in php-fpm pool
        server unix:/tmp/php-fpm.sock;
        # server 127.0.0.1:9000;
    }

    # include sites-enabled/*;

	# Redirect everything to the main site. We use a separate server statement and NOT an if statement - see https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/

	server {
		server_name  _;
		return 302 $scheme://example.com$request_uri;
	}

	server {
		server_name example.com;
		root /var/www/example.com;

		index index.php;

		include global/restrictions.conf;

		# Additional rules go here.

		# Only include one of the files below.
		include global/wordpress.conf;
		# include global/wordpress-ms-subdir.conf;
		# include global/wordpress-ms-subdomain.conf;

		# Global restrictions configuration file.
		# Designed to be included in any server {} block.
		location = /favicon.ico {
			log_not_found off;
			access_log off;
		}

		location = /robots.txt {
			all	ow all;
			log_not_found off;
			access_log off;
		}

		# Deny all attempts to access hidden files such as .htaccess, .htpasswd, .DS_Store (Mac).
		# Keep logging the requests to parse later (or to pass to firewall utilities such as fail2ban)
		location ~ /\. {
			deny all;
		}

		# Deny access to any files with a .php extension in the uploads directory
		# Works in sub-directory installs and also in multisite network
		# Keep logging the requests to parse later (or to pass to firewall utilities such as fail2ban)
		location ~* /(?:uploads|files)/.*\.php$ {
			deny all;
		}
	}
}